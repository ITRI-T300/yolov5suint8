/****************************************************************************
*   Generated by ACUITY 6.21.1
*   Match ovxlib 1.1.30
*
*   Neural Network appliction post-process source file
****************************************************************************/
/*-------------------------------------------
                Includes
-------------------------------------------*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <float.h>

#include <opencv2/core/core.hpp>
#include <opencv2/highgui/highgui.hpp>
#include <opencv2/imgproc/imgproc.hpp>

extern "C" {
#include "vsi_nn_pub.h"

#include "vnn_global.h"
//#include "vnn_post_process.h"
}
#include "vnn_post_process.hpp"

#define _BASETSD_H

#define DETECT_RESULT_IMPL 1

#define DRAW_RESULT 1

/*-------------------------------------------
                  Variable definitions
-------------------------------------------*/
#if DETECT_RESULT_IMPL

#define OUT_N 4
#define MAX_PICKED_NUM 100

static vsi_nn_tensor_t *tensors[OUT_N]; // output tensors
static uint8_t *out[OUT_N] = { -1, -1, -1, -1 }; // output tensor data
static float *d2f[OUT_N]; // dtype to float table for output tensors
static int dn;
#endif

/*{graph_output_idx, postprocess}*/
const static vsi_nn_postprocess_map_element_t* postprocess_map = NULL;


/*-------------------------------------------
                  Functions declaration
-------------------------------------------*/
#if DETECT_RESULT_IMPL
static void generate_proposals(int i, float prob_threshold, Objects *objs);
static void nms_sorted_bboxes(Objects *objects, int *picked, float nms_threshold);

static void post_proc_init(vsi_nn_graph_t *graph);
static void post_proc_process(vsi_nn_graph_t *graph);
static void post_proc_deinit();
#endif


/*-------------------------------------------
                  Functions
-------------------------------------------*/

#if DETECT_RESULT_IMPL
static inline float sigmoid(float x)
{
	return (float)(1.f / (1.f + exp(-x)));
}

static void generate_proposals(int i, float prob_threshold, Objects *objs)
{
static const int anchor_num = 3;
	static const int cls_num_p5 = 80 + 5;
    // int obj_idx = 0;
	int stride = 1 << (i + 3);
	int feat_w = 640 / stride;
	int feat_h = 640 / stride;
	float *ff = d2f[i];
	float *sf = ff + dn;
	uint8_t *feat = out[i];
	int s = 0;
	int e = feat_h;

	for (int h = s; h < e; h++) {
		for (int w = 0; w < feat_w; w++) {
			for (int a = 0; a < anchor_num; a++) {
				uint8_t *p = feat + ((a * feat_h + h) * feat_w + w) * cls_num_p5;

				// process cls score
				int class_index = 0;
				int16_t class_score = -INT16_MAX;

				for (int k = 5; k < cls_num_p5; k++) {
					int16_t t = p[k];
					if (class_score < t) {
						class_score = t;
						class_index = k;
					}
				}

				// process box score
				float final_score = sf[p[4]] * sf[(uint16_t)class_score];
				if (final_score >= prob_threshold) {
					static const float anchors[OUT_N][3][2] = {
						{ { 10, 13 }, { 16, 30 }, { 33, 23 } },
						{ { 30, 61 }, { 62, 45 }, { 59, 119 } },
						{ { 116, 90 }, { 156, 198 }, { 373, 326 } }
					};
					float dx = sf[p[0]];
					float dy = sf[p[1]];
					float dw = sf[p[2]];
					float dh = sf[p[3]];
					int pred_cx = (dx * 2.0f - 0.5f + w) * stride;
					int pred_cy = (dy * 2.0f - 0.5f + h) * stride;
					int pred_w = dw * dw * 4.0f * anchors[i][a][0];
					int pred_h = dh * dh * 4.0f * anchors[i][a][1];

					Object *pobj = &objs->obj[objs->num];
					pobj->rect.width = pred_w;
					pobj->rect.height = pred_h;
					pobj->rect.x = pred_cx - pred_w / 2;
					pobj->rect.y = pred_cy - pred_h / 2;
					pobj->label = class_index - 5;
					pobj->prob = final_score;
                    // printf("Lory debug:%s %d idx:%d prob:%f\n", __FUNCTION__, __LINE__, objs->num, final_score);

                    objs->num++;

                    if(objs->num > MAX_OBJECT_NUM)
                    {
                        /*sample flow not handle the data out of the objects max size*/
                        break;
                    }
				}
			}
		}
	}
}

static float calculate_iou(const Rect *a, const Rect *b) 
{  
    float inter_w = fmin(a->x + a->width, b->x + b->width) - fmax(a->x, b->x);  
    float inter_h = fmin(a->y + a->height, b->y + b->height) - fmax(a->y, b->y);  
    if (inter_w < 0 || inter_h < 0) return 0.0;  
  
    float inter_area = inter_w * inter_h;  
    float union_area = a->width * a->height + b->width * b->height - inter_area;  
    return inter_area / union_area;  
}  

static void nms_sorted_bboxes(Objects *objects, int *picked, float nms_threshold) 
{  
    if (objects->num <= 0) return; 

    //sort objects in descending order of prob
    for (int i = 0; i < objects->num - 1; i++) {
        for (int j = i + 1; j < objects->num; j++) {
            if (objects->obj[i].prob < objects->obj[j].prob) {
                Object temp = objects->obj[i];
                objects->obj[i] = objects->obj[j];
                objects->obj[j] = temp;
            }
        }
    }

    // initial picked array
    memset(picked, 0, sizeof(int) * MAX_PICKED_NUM);
    
    // picked[0] = 0;
    for (int i = 0; i < objects->num; i++) {
        //if the object has been marked as suppressed, skip it 
        if (picked[i] < -1) continue;

        for (int j = i + 1; j < objects->num; j++) {
            //if the object has not been suppressed
            if (picked[j] != -1) {
                float iou = calculate_iou(&objects->obj[i].rect, &objects->obj[j].rect);
                if (iou > nms_threshold) {
                    picked[j] = -1; // suppress the object
                }else{
                    picked[j] = j;
                }
            }
        }
    }
}

static void post_proc_init(vsi_nn_graph_t *graph)
{
	/* Create translate table for output tensors: dtype to float */
	dn = (1 << 8);

	for (int j = 0; j < OUT_N; j++) {
		float *f = (float *)malloc((dn + dn) * sizeof(float));
		tensors[j] = vsi_nn_GetTensor(graph, graph->output.tensors[j]);
		d2f[j] = f;
		for (int i = 0; i < dn; i++) {
			vsi_nn_DtypeToFloat32((uint8_t *)&i, f + i, &tensors[j]->attr.dtype);
			f[i + dn] = sigmoid(f[i]);
		}
	}
}

static void post_proc_process(vsi_nn_graph_t *graph, std::vector<Object>& objs)
{
    
    static float nms_threshold  = 0.45f;
    static float prob_threshold = 0.25f;
    static Objects objects;
    static Objects *proposals = &objects;
    static int picked[MAX_PICKED_NUM];
    static int *ppicked=picked;

    for (int j = 0; j < OUT_N; j++) {
		out[j] = vsi_nn_ConvertTensorToData(graph, tensors[j]);
    }

    if (!out[0])
	return;

    objects.num = 0;
    memset(&objects.obj, 0, sizeof(objects.obj));
    memset(&picked, 0, sizeof(picked));
    
    for (int i = 1; i < OUT_N; i++)
        generate_proposals(i, prob_threshold, &objects);

    nms_sorted_bboxes(proposals, ppicked/*&picked*/, nms_threshold);

    for (size_t i = 0; i < MAX_PICKED_NUM && i < proposals->num; i++) {
        if(picked[i] >= 0){
            Object obj = proposals->obj[picked[i]];
#if !DRAW_RESULT
            printf("obj: L:%2d P:%.02f, [(%d, %d) - (%d, %d)]\n", 
                obj.label, obj.prob, 
                (int)obj.rect.x, (int)obj.rect.y, (int)obj.rect.width, (int)obj.rect.height);
#endif
	    objs.push_back(obj);
        }
    }
}

static void post_proc_deinit()
{
    for (int j = 0; j < OUT_N; j++) {
        if(out[j]){
    		free(out[j]);
            out[j] = NULL;
        }
        if(d2f[j]){
            free(d2f[j]);
            d2f[j] = NULL;
        }
	}
}
#endif

static void save_output_data(vsi_nn_graph_t *graph)
{
    uint32_t i;
#define _DUMP_FILE_LENGTH 1028
#define _DUMP_SHAPE_LENGTH 128
    char filename[_DUMP_FILE_LENGTH] = {0}, shape[_DUMP_SHAPE_LENGTH] = {0};
    vsi_nn_tensor_t *tensor;

    for(i = 0; i < graph->output.num; i++)
    {
        tensor = vsi_nn_GetTensor(graph, graph->output.tensors[i]);
        vsi_nn_ShapeToString( tensor->attr.size, tensor->attr.dim_num,
            shape, _DUMP_SHAPE_LENGTH, FALSE );
        snprintf(filename, _DUMP_FILE_LENGTH, "output%u_%s.dat", i, shape);
        vsi_nn_SaveTensorToBinary(graph, tensor, filename);

    }
}

static vsi_bool get_top
    (
    float *pfProb,
    float *pfMaxProb,
    vsi_size_t *pMaxClass,
    vsi_size_t outputCount,
    vsi_size_t topNum
    )
{
    vsi_size_t i, j, k;

    #define MAX_TOP_NUM 20
    if (topNum > MAX_TOP_NUM) return FALSE;

    memset(pfMaxProb, 0xfe, sizeof(float) * topNum);
    memset(pMaxClass, 0xff, sizeof(vsi_size_t) * topNum);

    for (j = 0; j < topNum; j++)
    {
        for (i=0; i<outputCount; i++)
        {
            for (k=0; k < topNum; k ++)
            {
                if(i == pMaxClass[k])
                    break;
            }

            if (k != topNum)
                continue;

            if (pfProb[i] > *(pfMaxProb+j))
            {
                *(pfMaxProb+j) = pfProb[i];
                *(pMaxClass+j) = i;
            }
        }
    }

    return TRUE;
}

static vsi_status show_top5
    (
    vsi_nn_graph_t *graph,
    vsi_nn_tensor_t *tensor
    )
{
    vsi_status status = VSI_FAILURE;
    vsi_size_t i,sz,stride;
    float *buffer = NULL;
    uint8_t *tensor_data = NULL;
    vsi_size_t MaxClass[5];
    float fMaxProb[5];
    vsi_size_t topk = 5;

    sz = 1;
    for(i = 0; i < tensor->attr.dim_num; i++)
    {
        sz *= tensor->attr.size[i];
    }

    if(topk > sz)
        topk = sz;

    stride = (vsi_size_t)vsi_nn_TypeGetBytes(tensor->attr.dtype.vx_type);
    if(stride == 0)
    {
        stride = 1;
    }
    tensor_data = (uint8_t *)vsi_nn_ConvertTensorToData(graph, tensor);
    buffer = (float *)malloc(sizeof(float) * sz);

    for(i = 0; i < sz; i++)
    {
        status = vsi_nn_DtypeToFloat32(&tensor_data[stride * i], &buffer[i], &tensor->attr.dtype);
    }

    if (!get_top(buffer, fMaxProb, MaxClass, sz, topk))
    {
        printf("Fail to show result.\n");
        goto final;
    }

    printf(" --- Top%d ---\n", topk);
    for(i = 0; i< topk; i++)
    {
        printf("%3d: %8.6f\n", MaxClass[i], fMaxProb[i]);
    }
    status = VSI_SUCCESS;

final:
    if(tensor_data)vsi_nn_Free(tensor_data);
    if(buffer)free(buffer);
    return status;
}

vsi_status vnn_PostProcessYolov5sUint8(vsi_nn_graph_t *graph, std::vector<Object>& objects)
{
    vsi_status status = VSI_FAILURE;

#if DETECT_RESULT_IMPL
    /*detect result sample implement*/
    post_proc_init(graph);
    post_proc_process(graph, objects);
    post_proc_deinit();

#else
    /* Show the top5 result */
    status = show_top5(graph, vsi_nn_GetTensor(graph, graph->output.tensors[0]));
    TEST_CHECK_STATUS(status, final);

    /* Save all output tensor data to txt file */
    save_output_data(graph);

final:
#endif

    return VSI_SUCCESS;
}

const vsi_nn_postprocess_map_element_t * vnn_GetPostProcessMap()
{
    return postprocess_map;
}

uint32_t vnn_GetPostProcessMapCount()
{
    if (postprocess_map == NULL)
       return 0;
    else
        return sizeof(postprocess_map) / sizeof(vsi_nn_postprocess_map_element_t);
}
